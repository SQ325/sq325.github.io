# docker命令行

# image

## Create

### 获取

`docker`

`search`

`pull`

- 例子

    ```powershell
    docker search centos
    docker search alpine --filter "is-officeial=true" #官方

    docker pull ubuntu:16.04
    ```

### 构建

`docker build`

> build命令根据Dockerfile文件中的FROM指令获取到镜像，然后重复地1）run（create和start）、2）修改、3）commit。在循环中的每一步都会生成一个新的层，因此许多新的层会被创建。

- 例子

    ```powershell
    docker build -t username/centos:6.7 .
    #-t ：指定要创建的目标镜像名
    #. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径
    ```

## Read

`docker`

- `image`
    - `ls` 只列出顶层image
    - `ls -a` 列出所有层image
    - `inspect` 展示image源数据
- `system`
    - `df` 查看空间使用
- `history` 递归地输出指定镜像的历史镜像。

- 例子

    ```powershell
    docker images #列出了所有顶层（top-level）镜像
    docker images -a #列出了所有的镜像，也可以说是列出了所有的可读层
    docker image ls ubuntu
    docker image ls ubuntu:18.04
    docker image ls -q # -q：只列出id
    docker image ls -f since=mongo:3.2 # -f --filter 过滤, since表示在mongo:3.2之后建立的image
    docker imgae ls -f before=mongo:3.2 # before表示在mongo:3.2之前建立的image
    docker image ls -f label=com.example.version=0.1 # 通过label过滤

    docker image ls --format "{{.ID}}: {{.Repository}}"
    5f515359c7f8: redis
    05a60462f8ba: nginx
    fe9198c04d62: mongo
    00285df0df87: <none>
    f753707788c5: ubuntu
    f753707788c5: ubuntu
    1e0c3dd64ccd: ubuntu

    docker image ls --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"
    IMAGE ID            REPOSITORY          TAG
    5f515359c7f8        redis               latest
    05a60462f8ba        nginx               latest
    fe9198c04d62        mongo               3.2
    00285df0df87        <none>              <none>
    f753707788c5        ubuntu              18.04
    f753707788c5        ubuntu              latest

    docker history image_name 
    ```

## Update

### 命名

`docker tag 0bc42f7ff218 webapp:1.0`

`docker tag webapp:1.0 webapp:latest`

### 修改

## Delete

> 删除镜像的过程其实是删除镜像内的镜像层

`docker image`

`rm` 移除最顶层（也可以说是镜像），你也可以使用-f参数来强制删除中间的只读层

镜像层被多个镜像共享时，只有当全部依赖的镜像全部被删除才能删除该镜像层。

`prune` 删除悬虚镜像

`prune -a` 删除所有没有使用的镜像

- 例子

    ```powershell
    docker image rm $(docker image ls -q -f before=mongo:3.2) # linux
    docker image rm $(docker image ls -q redis) # linux

    docker rmi $(docker images | grep -v RESPOSITORY | awk '{print $3}') #删除所有images
    ```

# container

> `ctrl + PQ` 退出容器并保持容器运行

![1096A1D9-FB1C-447F-AE00-E12F4D12C2B7.jpeg](docker%E5%91%BD%E4%BB%A4%E8%A1%8C%2022a3bbe33f9e4a68a8303c8032fd2095/1096A1D9-FB1C-447F-AE00-E12F4D12C2B7.jpeg)

`docker events`

`docker pause` **docker pause does not stop the container processes. Instead it suspends the container processes. In this state the container is not consuming CPU but would still keep its portion of the memory.**

## Create

- `**docker run**[OPTIONS] IMAGE [COMMAND] [ARG...]`
    - `i`: 容器的标准输入保持打开
    - `t`: 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上
    - `d`: 守护模式
    - `network`

        ```bash
        --network=bridge 
        --network=host #使用宿主网络
        --network=containerNameOrId #使用已有container网络
        --network=none #不配置网络
        ```

    - `p` 一个端口只能绑定一个container，可多次绑定

        ip:hostPost:containerPort 指定地址的指点端口映射

        ip::containerPort 主机随机端口映射到container

        hostPort:containerPort

        containerPort 主机随机端口映射到container

    - `P` 随机映射一个 49000~49900 的端口到内部容器开放的网络端口
    - `rm`: 退出后即产出
    - `restart` 重启策略
        - *always*：会在daemon重启的时候重启
        - *unless-stopped：*不会在daemon重启的时候重启
        - *on-failed*
    - `mount`

        `—-mount souce=my-vol,target=/webapp` 加载一个volume到container的/webapp目录，如果my-vol不存在会创建

        `—-mount type=bind,source=/src/webapp,target=/opt/webapp,readonly` 加载host的/src/webapp到container的/opt/webapp，

    - `docker run` 创建容器的流程
        - 检查本地是否存在指定的镜像，不存在就从公有仓库下载
        - 利用镜像创建并启动一个容器
        - 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
        - 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
        - 从地址池配置一个 ip 地址给容器
        - 执行用户指定的应用程序
        - 执行完毕后容器被终止

`docker create` 

> 为指定的镜像（image）添加了一个可读写层，构成了一个新的容器

- 网络相关选项

    其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。

    - `b BRIDGE` 或 `-bridge=BRIDGE` 指定容器挂载的网桥
    - `-bip=CIDR` 定制 docker0 的掩码
    - `H SOCKET...` 或 `-host=SOCKET...` Docker 服务端接收命令的通道
    - `-icc=true|false` 是否支持容器之间进行通信
    - `-ip-forward=true|false` 请看下文容器之间的通信
    - `-iptables=true|false` 是否允许 Docker 添加 iptables 规则
    - `-mtu=BYTES` 容器网络中的 MTU

    下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 `docker run` 时可以覆盖设置的默认值。

    - `-dns=IP_ADDRESS...` 使用指定的DNS服务器
    - `-dns-search=DOMAIN...` 指定DNS搜索域

    最后这些选项只有在 `docker run` 执行时使用，因为它是针对容器的特性内容。

    - `h HOSTNAME` 或 `-hostname=HOSTNAME` 配置容器主机名
    - `-link=CONTAINER_NAME:ALIAS` 添加到另一个容器的连接
    - `-net=bridge|none|container:NAME_or_ID|host` 配置容器的桥接模式
    - `p SPEC` 或 `-publish=SPEC` 映射容器端口到宿主主机
    - `P or --publish-all=true|false` 映射容器所有端口到宿主主机

    ```powershell
    docker run -it --rm \
    	ubuntu:16.04 \
    	--netwrok localnet \ #使用名为loaclnet的网络
    	-p 5000:80 # 把host5000端口映射到container的80端口
    	-p 
    	/bin/bash

    docker run --name neversaydie -it --restart always alpine sh

    ```

## Read

`docker inspect` 提取出容器或者镜像最顶层的元数据

`docker stats` 容器使用资源情况

`docker top` 现实容器内进程top

`docker ps` 正在运行的container

`docker ps -a` 全部container

`docker diff <container>` 查看container中文件变化

## Update

### 启动

`docker container`

- `start` 将一个已经终止的容器启动运行、

    > 为容器文件系统创建了一个进程隔离空间

- `restart` 将一个运行态的容器终止，然后再重新启动

### 停止

`docker container`

- `stop`  终止一个运行中的容器

    > 向运行中的容器发送一个SIGTERM的信号，然后停止所有的进程

- `kill`

    > 向所有运行在容器中的进程发送了一个不友好的SIGKILL信号

- `pause`

    > 利用了cgroups的特性将运行中的进程空间暂停

只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。

当 Docker 容器中指定的应用终结时，容器也自动终止。

### 更新

`docker commit`

> 将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像

- 例子

    ```powershell
    docker commit -m="has update" -a="youj" e218edb10161 w3cschool/ubuntu:v2
    #-m:提交的描述信息
    #-a:指定镜像作者
    #e218edb10161：容器ID
    #w3cschool/ubuntu:v2:指定要创建的目标镜像名
    ```

### 进入

`docker`

`exec` 在运行中的容器执行一个新进程

```powershell
docker container exec -it <container_name> <command>
```

### 日志

`docker container logs [container ID or NAMES]`

## Delete

`docker container`

`rm` 移除构成容器的可读写层

`prune`

- 例子

    ```powershell
    docker container rm  trusting_newton #删除一个处于终止状态的容器
    docker container rm -f trusting_newton #删除一个运行中的容器
    docker container prune #清理掉所有处于终止状态的容器
    docker rm $(docker ps -a) #linux下删除所有container
    ```

## 容器的导入导出

> export相当于保存container的快照，丢失了image的元数据和历史信息。

`docker`

- `save` 创建一个镜像的tar文件，这个文件能够在另外一个主机的Docker上使用。和export命令不同，这个命令为每一个层都保存了它们的元数据。这个命令只能对镜像生效。
- `export` 创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容
- `load`
- `import`

**container → image**

`docker commit webapp`

**image → file**

`docker save webapp:1.0 > webapp-1.0.tar`

`docker save -o ./webapp-1.0.tar webapp:1.0`

`docker save -o ./images.tar webapp:1.0 nginx:1.12 mysql:5.7`

**file → image** 

`docker load < webapp-1.0.tar`

`docker load -i webapp-1.0.tar`

`cat ubuntu.tar | docker import - test/ubuntu:v1.0`

`docker import ./webapp.tar webapp:1.0`

**container → file** 

`docker export -o ./webapp.tar webapp`

# network

`docker`

`network`

- create
- ls
- inspect
- rm
- prune

`port`

## create

```powershell
docker network create -d bridge lcoalnet #创建名为localnet的网桥
```

## read

```bash
docker netwrok ls 
docker network inspect 
docker port
```

## update

## delete

```bash
docker network rm 
docker netwrok prune #删除未使用的网络
```

# volume

`docker`

`volume`

- create
- ls
- inspect
- rm
- prune

## create

```bash
docker create my-vol
```

## read

```docker
docker volume ls
docker volume inspect <volume>
```

## delete

```bash
docker volume rm my-vol
docker volume prue #删除无container使用的volume
```

# docker daemon

linux

```bash
service docker status 
systemctl is-active docker

```

windows

```powershell
Get-Sevice docker
```